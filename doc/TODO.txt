Tehtävää aika- ja riippuvuusjärjestyksessä:

1. Luokat ValueSet ja KeyValueSet
   * Käyttötarkoitus:
     1. lista vapaista oskillaattoreista        
     2. lista soivista oskillaattoreista, nuottilähde GUI
     3. lista soivista oskillaattoreista, nuottilähde MIDI      
   * toteutus: kiinteän kokoinen taulukko (koko = synan polyfonia)
   * listan EI tarvitse olla järjestyksessä, joten saadaan lisäys ja poisto
     vakioajassa/olio seuraavalla menettelyllä (parempi kuin STL:n vector!):
     Lisäys taulukon seuraavaan vapaaseen paikkaan:
        taulukko[kaytossa++] = lisattavaArvo;
     Poisto: poistetaan halutun indeksin kohdalta, kopioidaan        
        taulukko[poistoIndeksi] = taulukko[kaytossa - 1];
        kaytossa--;
        (tai paremmin: taulukko[poistoIndeksi] = taulukko[--kaytossa];)
        
   Note on -tapahtuma:
   oskillaattoriIndeksi = vapaat.pop();
   soivat.push(oskillaattoriIndeksi, kosketin);
   
   Note off -tapahtuma:
   soivat.remove(kosketin);
   vapaat.push(oskillaattoriIndeksi);
   
   All notes off -tapahtuma:
   while (guiNuotit.size() != 0) {
       oskillaattoriIndeksi = guiNuotit.pop();
       vapaat.push(oskillaattoriIndeksi);
   }
   
   Vapaat oskillaattorit tallennetaan ValueSet-olioon.
   Soivat oskillaattorit tallennetaan KeyValueSet-olioon.
   
   Luokka FixedIndexMap periytyy luokasta FixedIndexSet.
   FixedIndexMapissa tallennetaan kosketin-oskillaattoriIndeksi-arvopareja.
   Kosketin toimii avaimena. Käytännössä FixedIndexMap sisältää
   unsigned short indexOfKey[256] -taulukon, jossa arvo 0..255 tarkoittaa
   indeksiä FixedIndexSet.valueTablessa ja 256 tarkoittaa, että kyseistä
   avainta ei ole tässä listassa.
   
   
   Pointteritoteuksen hyvät ja huonot puolet:
   + päästään hieman nopeammin käsiksi
   - vain mainOscillatorien pointtereita. Kun lfo moduloi
   - sitten tulevaisuudessa, kun useampi mainOscillator per nuotti, niin
     pitäisi tallentaa pointteriryhmiä. Kuulostaa vaivalloiselta 
   
   int- tai unsigned char -toteutuksen hyvät ja huonot puolet
   + tilansäästö: indeksit 0-255 riittävät hyvin, silloin unsigned char
     riittäisi
   + ei turhaa, vaarallista pointteriräpläystä
   + helpompi debuggaus
   - indeksi täytyy muuntaa vielä pointteriksi oskillaattoriolioon
   
3. Synthesizer-luokka
   - Sopivat tietorakenteet oskillaattoreille

   1. Jono: vapaat oskillaattorit
      Toteutus: STL:n deque. Toisaalta jonon maksimipituus tiedetään, ja
      jonoon tallennetaan pointtereita oskillaattoreihin tai indeksejä,
      joten jonon voisi toteuttaa taulukkona. Jonon sisältö kuitenkin vaihtuu
      nopeasti, joten kiinteä taulukkototeutus ei fragmentoisi muistia.
      
      
   2. Lista: soivat oskillaattorit, joiden nuottilähde on GUI
   3. Lista: soivat oskillaattorit, joiden nuottilähde on MIDI
      Tässäkin kiinteä taulukkokoteutus olisi hyvä.


   Huom! Tallenna vapaat oskillaattorit jonona. Käytännön toteutus voi
   olla taulukko tai STL:n jono. On tehottomampaa käydä läpi kaikki
   oskillaattorit etsien ensimmäistä vapaata aina, kun tulee uusi nuotti.
   (Tämän takia synth.c:n muuttujaa osc_mute ei enää tarvita.)
   
   Huom! Tehokasta note offia varten pitää tehdä taulukot
   MainOscillator * GuiNotes[128]; ja
   MainOscillator * MidiNotes[128];
   Indeksinä on suoraan nuotin koskettimen numero (MIDI-numeroinnilla).
   Kun tulee note off, niin note offin lähteestä (Gui, MIDI) riippuen
   tsekataan jommastakummasta taulukosta oikea MainOscillator.
   Kun tulee all notes off, niin on ihan riittävän nopeaa käydä 128
   nuotin taulukko läpi (Tällaista erikoistapausta varten ei yksinään kannata
   tehdä listaa kummankin nuottilähteen soivista oskillaattoreista.)

   - metodit processNoteOn, processNoteOff, processFastMute.
   - metodi processParameterChange
       - Eri parametreja on paljon. Kannattaako tehdä arvon haarukointi
         pitkän switch-lauseen sijaan?
         
   - äänentuottometodi
     

   

   Kolme äänisynteesipuskuria Synthesizerissä riittää:
   1. LFO:n ääni. Jos LFO:n taajuus on kiinteä, niin LFO:n ääni on kaikille
      MainOscillatoreille sama. Silloin LFO tarvitsee laskea vain kerran.
   2. MainOscillatorin ääni.
   3. Miksaus. Jokainen soiva MainOscillator generoidaan vuorollaan ja
      summataan miksauspuskuriin.   
   
   Kun LFO moduloi, niin Synthesizer kuitenkin aina kutsuu
   LowFrequencyOscillator.generateSound():ia.
   LFO piirtää sille annettuun aaltotaulukkoon signaalinsa, ja sitten
   aaltotaulukko annetaan edelleen osoitinparametrina
   MainOscillator.generateSound():ille.

   Kun LFO:n taajuus riippuu pääoskillaattorin taajuudesta, niin
   pääoskillaattorin pärähtäessä soimaan se asettaa LFO:n taajuuden.
   (Pääoskillaattorissa on viittaus sille varattuun LFO:hon.)
   
   C-version synth.c:n handle_parameter_change():ssa voisi yhden jättimäisen
   switch-lauseen sijasta tehdä haarukointeja SynthGui::buttonSelectin tapaan.


  
8. luokka Filter
   
9. Optimointia: kannattaako oskillaattorin äänisynteesi laittaa inlineksi?
   Tietenkin se kiehtoisi, mutta ei taida onnistua, koska metodeissa on
   paikallisia muuttujia. Muutenkaan varsinaisen oskillaattorin äänisynteesi
   ei ole pelkästään aaltotaulukosta lukujen napsimista ja arvojen summaamista
   miksauspuskuriin. Muista modulointi.
   



